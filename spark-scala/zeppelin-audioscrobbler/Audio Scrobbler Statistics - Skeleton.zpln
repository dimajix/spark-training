{"paragraphs":[{"text":"%md\n# Analysing Audioscrobbler Data\n\nIn this notebook we want to create two very simple statistics on artists from data provided by Audioscrobbler. We are working with three related data sets:\n\n1. A list of users containing their number of plays per artist\n2. A list which maps a generic artist-id to its real (band) name\n3. A list which maps bad artist ids to good ones (fixing typing errors)\n\nThen we will ask two simple questions:\n1. Which artists have the most listeners (in terms of number of unique users)\n2. Which artists are played most often (in terms of total play counts)","dateUpdated":"2018-04-10T06:14:21+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Analysing Audioscrobbler Data</h1>\n<p>In this notebook we want to create two very simple statistics on artists from data provided by Audioscrobbler. We are working with three related data sets:</p>\n<ol>\n<li>A list of users containing their number of plays per artist</li>\n<li>A list which maps a generic artist-id to its real (band) name</li>\n<li>A list which maps bad artist ids to good ones (fixing typing errors)</li>\n</ol>\n<p>Then we will ask two simple questions:</p>\n<ol>\n<li>Which artists have the most listeners (in terms of number of unique users)</li>\n<li>Which artists are played most often (in terms of total play counts)</li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1523340861584_-2075684046","id":"20180410-055942_688799353","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:4125"},{"text":"import org.apache.spark.sql.types._","dateUpdated":"2018-04-10T06:14:21+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861585_-2076068795","id":"20180410-053802_720924579","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4126"},{"text":"%md\n# Preparations\n\nBefore we jump into the questions, we first read in all data and apply the mapping of bad artist IDs to good artist ids.","dateUpdated":"2018-04-10T06:14:21+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Preparations</h1>\n<p>Before we jump into the questions, we first read in all data and apply the mapping of bad artist IDs to good artist ids.</p>\n"}]},"apps":[],"jobName":"paragraph_1523340861585_-2076068795","id":"20180410-060226_1821926409","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4127"},{"text":"%md\n## P1. Read in User-Artist-Data\n\nFirst we read in the most important data set, containing the information how often a user played songs of a specific artist. This information is stored in the file at `s3://dimajix-training/data/audioscrobbler/user_artist_data/`. The file has the following characteristics:\n* Format: CSV (kind of)\n* Separator: Space (\" \")\n* Header: No\n* Fields: user_id (INT), artist_id(INT), play_count(INT)\n\nSo we need to read in this file and store it in a local variable `user_artist_data`. Since we do not have any header contained in the file itself, we need to specify the schema explicitly.","dateUpdated":"2018-04-10T06:14:21+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>P1. Read in User-Artist-Data</h2>\n<p>First we read in the most important data set, containing the information how often a user played songs of a specific artist. This information is stored in the file at <code>s3://dimajix-training/data/audioscrobbler/user_artist_data/</code>. The file has the following characteristics:</p>\n<ul>\n<li>Format: CSV (kind of)</li>\n<li>Separator: Space (&rdquo; &ldquo;)</li>\n<li>Header: No</li>\n<li>Fields: user_id (INT), artist_id(INT), play_count(INT)</li>\n</ul>\n<p>So we need to read in this file and store it in a local variable <code>user_artist_data</code>. Since we do not have any header contained in the file itself, we need to specify the schema explicitly.</p>\n"}]},"apps":[],"jobName":"paragraph_1523340861585_-2076068795","id":"20180410-060340_1957766096","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4128"},{"text":"val schema = StructType(\n        // YOUR CODE HERE\n    )\n    \nval user_artist_data = // YOUR CODE HERE\n\nz.show(user_artist_data, 10)","dateUpdated":"2018-04-10T06:15:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861586_-2074914548","id":"20180410-053305_1209301817","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4129"},{"text":"%md\n## P2 Read in artist aliases\n\nNow we read in a file containing mapping of bad artist IDs to good IDs. This fixes typos in the artists names and thereby enables us to merge information with different artist IDs belonging to the same band. This information is stored in the file at `s3://dimajix-training/data/audioscrobbler/artist_alias/`. The file has the following characteristics:\n* Format: CSV (kind of)\n* Separator: Tab (\"\\t\")\n* Header: No\n* Fields: bad_id (INT), good_id(INT)\n\nSo we need to read in this file and store it in a local variable `artist_alias`. Since we do not have any header contained in the file itself, we need to specify the schema explicitly.","dateUpdated":"2018-04-10T06:14:21+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>P2 Read in artist aliases</h2>\n<p>Now we read in a file containing mapping of bad artist IDs to good IDs. This fixes typos in the artists names and thereby enables us to merge information with different artist IDs belonging to the same band. This information is stored in the file at <code>s3://dimajix-training/data/audioscrobbler/artist_alias/</code>. The file has the following characteristics:</p>\n<ul>\n<li>Format: CSV (kind of)</li>\n<li>Separator: Tab (&ldquo;\\t&rdquo;)</li>\n<li>Header: No</li>\n<li>Fields: bad_id (INT), good_id(INT)</li>\n</ul>\n<p>So we need to read in this file and store it in a local variable <code>artist_alias</code>. Since we do not have any header contained in the file itself, we need to specify the schema explicitly.</p>\n"}]},"apps":[],"jobName":"paragraph_1523340861586_-2074914548","id":"20180410-060636_826552422","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4130"},{"text":"val schema = // YOUR CODE HERE\n    \nval artist_alias = // YOUR CODE HERE\n\nz.show(artist_alias, 10)","dateUpdated":"2018-04-10T06:15:16+0000","config":{"colWidth":12,"results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861586_-2074914548","id":"20180410-053349_315669178","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4131"},{"text":"%md\n## P3 Read in artist aliases\n\nThe third file contains the artists name for his/her id. We also use this file in order to be able to display results with the artists names instead of their IDs. This information is stored in the file at `s3://dimajix-training/data/audioscrobbler/artist_data/`. The file has the following characteristics:\n* Format: CSV (kind of)\n* Separator: Tab (\"\\t\")\n* Header: No\n* Fields: artist_id (INT), artist_name(STRING)\n\nSo we need to read in this file and store it in a local variable `artist_data`. Since we do not have any header contained in the file itself, we need to specify the schema explicitly.","dateUpdated":"2018-04-10T06:14:21+0000","config":{"editorSetting":{"language":"text","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/text","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>P3 Read in artist aliases</h2>\n<p>The third file contains the artists name for his/her id. We also use this file in order to be able to display results with the artists names instead of their IDs. This information is stored in the file at <code>s3://dimajix-training/data/audioscrobbler/artist_data/</code>. The file has the following characteristics:</p>\n<ul>\n<li>Format: CSV (kind of)</li>\n<li>Separator: Tab (&ldquo;\\t&rdquo;)</li>\n<li>Header: No</li>\n<li>Fields: artist_id (INT), artist_name(STRING)</li>\n</ul>\n<p>So we need to read in this file and store it in a local variable <code>artist_data</code>. Since we do not have any header contained in the file itself, we need to specify the schema explicitly.</p>\n"}]},"apps":[],"jobName":"paragraph_1523340861586_-2074914548","id":"20180410-060849_2002551425","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4132"},{"text":"val schema = // YOUR CODE HERE\n\nval artist_data = // YOUR CODE HERE\n    \nz.show(artist_data, 10)","dateUpdated":"2018-04-10T06:15:29+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861587_-2075299297","id":"20180410-053529_1777379660","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4133"},{"text":"%md\n## P4 Clean Data - Replace wrong Artists\n\nBefore continuing with the analysis, we first create a cleaned version of the `artist_user_data` table with the `artist_alias` mapping applied. This means that we need to lookup each artist-id in the original data set in the alias data set and see if we find have a matching `bad_id` entry with a replacement `good_id`. The result should be stored in a variable `cleanedUserArtistData`. This DataFrame should contain the columns Finally select only the columns `user_id`, `artist_id` (the corrected one) and `play_count`\n\nHints:\n1. Join the user artist data DataFrame with the artist alias DataFrame containing fixes for some artists. Which join type is appropriate?\n2. Replace the artist-id in the user artists data with the `good_id` from the artist alias DataFrame - if a match is found on `bad_id`\n3. Finally select only the columns `user_id`, `artist_id` (the corrected one) and `play_count`","dateUpdated":"2018-04-10T06:14:21+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>P4 Clean Data - Replace wrong Artists</h2>\n<p>Before continuing with the analysis, we first create a cleaned version of the <code>artist_user_data</code> table with the <code>artist_alias</code> mapping applied. This means that we need to lookup each artist-id in the original data set in the alias data set and see if we find have a matching <code>bad_id</code> entry with a replacement <code>good_id</code>. The result should be stored in a variable <code>cleanedUserArtistData</code>. This DataFrame should contain the columns Finally select only the columns <code>user_id</code>, <code>artist_id</code> (the corrected one) and <code>play_count</code></p>\n<p>Hints:</p>\n<ol>\n<li>Join the user artist data DataFrame with the artist alias DataFrame containing fixes for some artists. Which join type is appropriate?</li>\n<li>Replace the artist-id in the user artists data with the <code>good_id</code> from the artist alias DataFrame - if a match is found on <code>bad_id</code></li>\n<li>Finally select only the columns <code>user_id</code>, <code>artist_id</code> (the corrected one) and <code>play_count</code></li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1523340861587_-2075299297","id":"20180410-054850_1118574695","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4134"},{"text":"val cleanedUserArtistData = // YOUR CODE HERE\n    \nz.show(cleanedUserArtistData, 10)    \n","dateUpdated":"2018-04-10T06:15:39+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861587_-2075299297","id":"20180410-054252_1751602409","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4135"},{"text":"%md\n# Question 1: Artist with most unique listeners\n\nWho are the artist with the most unique listeners? For this question, it is irrelevant how often an individul user has played songs of a specific artist. It is only important how many different users have played each artists work. Of course we do not want to see the artist-id, but their real names as provided in the DataFrame `artist_data`!\n\nHints:\n1. Group cleaned data by `artist_id`\n2. Perform aggregation by counting unique user ids\n3. Join `artist_data`\n4. Lookup the artists name\n5. Sort result by descending user counts","dateUpdated":"2018-04-10T06:14:21+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Question 1: Artist with most unique listeners</h1>\n<p>Who are the artist with the most unique listeners? For this question, it is irrelevant how often an individul user has played songs of a specific artist. It is only important how many different users have played each artists work. Of course we do not want to see the artist-id, but their real names as provided in the DataFrame <code>artist_data</code>!</p>\n<p>Hints:</p>\n<ol>\n<li>Group cleaned data by <code>artist_id</code></li>\n<li>Perform aggregation by counting unique user ids</li>\n<li>Join <code>artist_data</code></li>\n<li>Lookup the artists name</li>\n<li>Sort result by descending user counts</li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1523340861587_-2075299297","id":"20180410-053551_1348623672","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4136"},{"text":"val result = // YOUR CODE HERE\n\nz.show(result, 10)","dateUpdated":"2018-04-10T06:15:48+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861588_-2077223042","id":"20180410-054800_976364716","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4137"},{"text":"%md\n# Question 2: Artist with most Plays\n\nNow we also take into account how often each user played the work of individual artists. That is, we also include the `play_coun` column into our calculations. So which artists have the most plays in total? Of course we do not want to see the artist-id, but their real names as provided in the DataFrame `artist_data`!\n\nHints:\n1. Group cleaned data by `artist_id`\n2. Perform aggregation by summing up play count\n3. Join `artist_data`\n4. Lookup the artists name\n5. Sort result by descending play counts\n","dateUpdated":"2018-04-10T06:14:21+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Question 2: Artist with most Plays</h1>\n<p>Now we also take into account how often each user played the work of individual artists. That is, we also include the <code>play_coun</code> column into our calculations. So which artists have the most plays in total? Of course we do not want to see the artist-id, but their real names as provided in the DataFrame <code>artist_data</code>!</p>\n<p>Hints:</p>\n<ol>\n<li>Group cleaned data by <code>artist_id</code></li>\n<li>Perform aggregation by summing up play count</li>\n<li>Join <code>artist_data</code></li>\n<li>Lookup the artists name</li>\n<li>Sort result by descending play counts</li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1523340861588_-2077223042","id":"20180410-055026_1272692418","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4138"},{"text":"val result = // YOUR CODE HERE\n\nz.show(result, 10)\n","dateUpdated":"2018-04-10T06:15:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861588_-2077223042","id":"20180410-055353_270948625","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4139"},{"dateUpdated":"2018-04-10T06:14:21+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523340861589_-2077607791","id":"20180410-055552_880825946","dateCreated":"2018-04-10T06:14:21+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4140"}],"name":"Audio Scrobbler Statistics - Skeleton","id":"2DB66AEBW","angularObjects":{"2BRWU4WXC:shared_process":[],"2AM1YV5CU:shared_process":[],"2AJXGMUUJ:shared_process":[],"2ANGGHHMQ:shared_process":[],"2AKK3QQXU:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}