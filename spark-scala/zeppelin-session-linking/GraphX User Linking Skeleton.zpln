{"paragraphs":[{"text":"%md\n# 1. Load Data\nWe load the data that we have prepared in the last exercise. Only you know where you have stored it, so don't ask me :)","dateUpdated":"2018-07-04T17:08:10+0000","config":{"editorSetting":{},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>1. Load Data</h1>\n<p>We load the data that we have prepared in the last exercise. Only you know where you have stored it, so don't ask me :)</p>\n"}]},"apps":[],"jobName":"paragraph_1530724090170_-1685514762","id":"20160610-195019_770962390","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:26996"},{"text":"val sessions = ... // YOUR CODE HERE\n\nsessions.printSchema()","dateUpdated":"2018-07-04T17:08:30+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090172_-1687823255","id":"20160611-090912_1498120381","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:26997"},{"text":"%md\n# 2. Create Indices usable for GraphX\nIn GraphX all Vertices are identified by 64bit Long values. But of course, our data is String based. Therefore we need to create an Index, which assigns a unique ID to every value which is to be used as a Vertex.\n\nWe will use both the sessions and the linking keys for vertices, so we need to create a common index for both key types.\n\nSo what we eventually want to do is the following:\n1. Get all session keys from the data, put them into a column `key`\n2. Get all linking keys from the data, put them into a column `key`\n3. Union these keys together (they are prefixed with sesn_ and cdk_, so they won't interfere)\n4. Make set of keys distinct\n5. Assign unique ID to each key using `zipWithUniqueId`. Theoretically the Spark DataFrame function `monotonically_increasing_id()` should also do the job, but it doesn't seem to produce stable results.\n\nNote that `zipWithUniqueId` only guarantees stable results between recomputations when the ordering of the elements is deterministic. Therefore we first sort all records before generating IDs.","dateUpdated":"2018-07-04T17:09:06+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>2. Create Indices usable for GraphX</h1>\n<p>In GraphX all Vertices are identified by 64bit Long values. But of course, our data is String based. Therefore we need to create an Index, which assigns a unique ID to every value which is to be used as a Vertex.</p>\n<p>We will use both the sessions and the linking keys for vertices, so we need to create a common index for both key types.</p>\n<p>So what we eventually want to do is the following:<br/>1. Get all session keys from the data, put them into a column <code>key</code><br/>2. Get all linking keys from the data, put them into a column <code>key</code><br/>3. Union these keys together (they are prefixed with sesn_ and cdk_, so they won&rsquo;t interfere)<br/>4. Make set of keys distinct<br/>5. Assign unique ID to each key using <code>zipWithUniqueId</code>. Theoretically the Spark DataFrame function <code>monotonically_increasing_id()</code> should also do the job, but it doesn&rsquo;t seem to produce stable results.</p>\n<p>Note that <code>zipWithUniqueId</code> only guarantees stable results between recomputations when the ordering of the elements is deterministic. Therefore we first sort all records before generating IDs.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1530724090173_-1688208004","id":"20160611-160136_407714042","dateCreated":"2018-07-04T17:08:10+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:26998","user":"anonymous","dateFinished":"2018-07-04T17:09:06+0000","dateStarted":"2018-07-04T17:09:06+0000"},{"text":"// Get session keys from data, add one more column marking this key as being a session key\nval sessionKeys = ... // YOUR CODE HERE\n\n// Get linking keys from data, add one more column marking this key as not being a session key\nval linkingKeys = ... // YOUR CODE HERE\n\n// Put both sets of keys together, and make entries distinct (drop duplicates)\nval keys = ... // YOUR CODE HERE\n\n// Create stable unique IDs. It is important to sort the data before calling zipWithIndex!\nval indexedKeys = ... // YOUR CODE HERE\n","dateUpdated":"2018-07-04T17:10:48+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","editorHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[{"name":"key","index":0,"aggr":"sum"}],"values":[{"name":"is_sessionkey","index":1,"aggr":"sum"}],"groups":[],"scatter":{"xAxis":{"name":"key","index":0,"aggr":"sum"},"yAxis":{"name":"is_sessionkey","index":1,"aggr":"sum"}}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090173_-1688208004","id":"20160611-090954_780732037","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:26999"},{"text":"z.show(indexedKeys.limit(10))","dateUpdated":"2018-07-04T17:08:10+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090174_-1687053757","id":"20160611-101412_1451752564","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27000"},{"text":"%md\n# 3. Create GraphX Representation\nSince we want to use GraphX for finding all connected keys, we need to prepare our data. We already created an appropriate index set for all vertices and edges, now we need to transform our original (relational) data into a GraphX representation. This will be done in three steps:\n1. Create Verticies representing linking keys and sessions\n2. Create Edges representing linking key usage in sessions\n3. Create Graph from Vertices and Edges","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>3. Create GraphX Representation</h1>\n<p>Since we want to use GraphX for finding all connected keys, we need to prepare our data. We already created an appropriate index set for all vertices and edges, now we need to transform our original (relational) data into a GraphX representation. This will be done in three steps:</p>\n<ol>\n<li>Create Verticies representing linking keys and sessions</li>\n<li>Create Edges representing linking key usage in sessions</li>\n<li>Create Graph from Vertices and Edges</li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1530724090175_-1687438506","id":"20180624-165550_384780347","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27001"},{"text":"%md\n## 3.1 Create Vertices\n\nNow we want to create vertices for GraphX. What is the set of vertices? Actually it's the whole set of keys, so every entry in our DataFrame 'indexedKeys' should be added to vertices. And that is pretty easy, since the required VertexID is just the 'index' column.\n\nWe simply use Spark Dataset operations to extract the Vertex ID and key using a `select` operation, the we cast the result into a Tuple using the Dataset `as` operation. Finally we extract the RDD from the Dataset, which will be our Vertices RDD.","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>3.1 Create Vertices</h2>\n<p>Now we want to create vertices for GraphX. What is the set of vertices? Actually it's the whole set of keys, so every entry in our DataFrame 'indexedKeys' should be added to vertices. And that is pretty easy, since the required VertexID is just the 'index' column.</p>\n<p>We simply use Spark Dataset operations to extract the Vertex ID and key using a <code>select</code> operation, the we cast the result into a Tuple using the Dataset <code>as</code> operation. Finally we extract the RDD from the Dataset, which will be our Vertices RDD.</p>\n"}]},"apps":[],"jobName":"paragraph_1530724090175_-1687438506","id":"20160611-101933_2130257741","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27002"},{"text":"// Create vertices from the indexedKeys. \nval vertices = indexedKeys.select($\"index\", $\"key\").as[(Long,String)].rdd\n\nvertices.take(10).foreach(println)","dateUpdated":"2018-07-04T17:08:10+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"vertices: org.apache.spark.rdd.RDD[(Long, String)] = MapPartitionsRDD[43] at rdd at <console>:26\n(0,cdk_0003X6MVGEjbaqv99fPED0KtyhZjgnoM)\n(200,cdk_000ExDVc3VLKzPHSmggGBbiVABYkxTpi)\n(400,cdk_000GGE3eFGOextrETnYx0YHrzuSBhqVu)\n(600,cdk_000OUiHQ1kV9KcqiuwBakloNJRvtLUV3)\n(800,cdk_000VZ92b0OgdulQpTXTYjEskhQA5C9El)\n(1000,cdk_000u21lfinjYXYu26oxKnPrPo8eTbgCu)\n(1200,cdk_000vhuAkQg0RZrlPhKshZtAN0PexoMTM)\n(1400,cdk_0010gVp75IDorUJWnFL8HI65CTwucT2d)\n(1600,cdk_0014XB3ISnHflVHnQ5vtZXPGvsVnAfM6)\n(1800,cdk_001H9NeM8bhy6R38UpRDZukp0ak4mAhH)\n"}]},"apps":[],"jobName":"paragraph_1530724090178_-1700904718","id":"20160611-101911_208120114","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27003"},{"text":"%md\n## 3.2 Create Edges\n\nNow that we have the vertices, we also need the Edges. Since the Edges actually make up the topology of the graph, they are obviously a little bit more complex than vertices. We want to create an Edge for every connection between a session and a linking key. We'll do that with the following approach:\n\n1. Join indexedKeys to sessions, replacing session key by the appropriate 'index' entry in the indexedKeys\n2. Join indexedKeys to the result, now replacing the linking key by the corresponding 'index' entry in indexedKeys\n3. Now you should have a DataFrame with two Long values, one for the session and one for the linking key.\n4. Each of these tuples need to be mapped to a GraphX Edge(cdkIndex, sessionIndex, 0)","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>3.2 Create Edges</h2>\n<p>Now that we have the vertices, we also need the Edges. Since the Edges actually make up the topology of the graph, they are obviously a little bit more complex than vertices. We want to create an Edge for every connection between a session and a linking key. We'll do that with the following approach:</p>\n<ol>\n<li>Join indexedKeys to sessions, replacing session key by the appropriate 'index' entry in the indexedKeys</li>\n<li>Join indexedKeys to the result, now replacing the linking key by the corresponding 'index' entry in indexedKeys</li>\n<li>Now you should have a DataFrame with two Long values, one for the session and one for the linking key.</li>\n<li>Each of these tuples need to be mapped to a GraphX Edge(cdkIndex, sessionIndex, 0)</li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1530724090179_-1701289467","id":"20160611-102114_62388765","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27004"},{"text":"import org.apache.spark.graphx.Edge\n\n// 1. Replace session keys by unique ID in indexed keys, keep linking key for next step\nval resolvedSession = // YOUR CODE HERE\n    \n// 2. Replace linking key by unique ID in indexed keys, keep ID from previous step\nval resolvedAll = // YOUR CODE HERE\n    \n// 3. Now you should have a DataFrame with columns for the ID of session and the ID for linking key\n\n// 4. Map all entries to Edge(session_id, cdk_id)\nval edges = resolvedAll.map(e => Edge[Long]( e.getAs[Long](0), e.getAs[Long](1), 0)).rdd","dateUpdated":"2018-07-04T17:12:27+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090179_-1701289467","id":"20160611-102127_1509360684","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27005"},{"text":"%md\n## 3.3 Create Graph\n\nNow we have everything together, we can create a GraphX Graph. This is now trivial, only the constructor needs to be called.","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>3.3 Create Graph</h2>\n<p>Now we have everything together, we can create a GraphX Graph. This is now trivial, only the constructor needs to be called.</p>\n"}]},"apps":[],"jobName":"paragraph_1530724090180_-1703213211","id":"20160611-102713_1849984677","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27006"},{"text":"import org.apache.spark.graphx.Graph\n\nval sessionGraph = // YOUR CODE HERE","dateUpdated":"2018-07-04T17:12:40+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090180_-1703213211","id":"20160611-102724_62333210","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27007"},{"text":"%md\n# 4. Find Connected Components\n\nNow comes the next interesting step. We want to find all connected components in our Graph. This can be done using some simple functionality provided by GraphX called ConnectedComponents. It will return a new Graph with the vertex properties (i.e. the value attached to each Vertex) replaced by an ID identifying the component. The ID is selected as follows (from documentation):\n\n>  Compute the connected component membership of each vertex and return a graph with the vertex value containing the lowest vertex id in the connected component containing that vertex. ","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>4. Find Connected Components</h1>\n<p>Now comes the next interesting step. We want to find all connected components in our Graph. This can be done using some simple functionality provided by GraphX called ConnectedComponents. It will return a new Graph with the vertex properties (i.e. the value attached to each Vertex) replaced by an ID identifying the component. The ID is selected as follows (from documentation):</p>\n<blockquote>\n  <p>Compute the connected component membership of each vertex and return a graph with the vertex value containing the lowest vertex id in the connected component containing that vertex.</p>\n</blockquote>\n</div>"}]},"apps":[],"jobName":"paragraph_1530724090180_-1703213211","id":"20160611-102906_472720527","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27008"},{"text":"import org.apache.spark.graphx.lib.ConnectedComponents\n\nval connectedGraph = // YOUR CODE HERE","dateUpdated":"2018-07-04T17:13:04+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090181_-1703597960","id":"20160611-102932_656235616","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27009"},{"text":"%md\n# 5. Map Back Session Keys\n\nNow we have a new graph, where each Vertex has an ID which maps to the original session key or linking key. The value of each Vertex denotes which component the Vertex (and therefore session or linking key) belongs to. By looking up all original session keys and keeping the component ID, we can find all sessions which belong together (those session keys having the same component ID belong to the same user).\n\nSo our plan looks as follows:\n1. Convert vertices from Graph back into a DataFrame with two columns 'original' and 'component'\n2. Join indexedKeys to the DataFrame on original_idx === index, look up session key\n3. Keep only session keys (so we can put sessions together. Otherwise we could also put linking keys together)\n4. Extract session key and component id, forget other columns\n\nThe result is a DataFrame with a component ID for every session. Now let's rename component_id to 'user_handle', which represents our mental concept of the table","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>5. Map Back Session Keys</h1>\n<p>Now we have a new graph, where each Vertex has an ID which maps to the original session key or linking key. The value of each Vertex denotes which component the Vertex (and therefore session or linking key) belongs to. By looking up all original session keys and keeping the component ID, we can find all sessions which belong together (those session keys having the same component ID belong to the same user).</p>\n<p>So our plan looks as follows:<br/>1. Convert vertices from Graph back into a DataFrame with two columns &lsquo;original&rsquo; and &lsquo;component&rsquo;<br/>2. Join indexedKeys to the DataFrame on original_idx === index, look up session key<br/>3. Keep only session keys (so we can put sessions together. Otherwise we could also put linking keys together)<br/>4. Extract session key and component id, forget other columns</p>\n<p>The result is a DataFrame with a component ID for every session. Now let&rsquo;s rename component_id to &lsquo;user_handle&rsquo;, which represents our mental concept of the table</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1530724090181_-1703597960","id":"20160611-123436_336815516","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27010"},{"text":"// 1. Convert Vertices back into a DataFrame. The first entry is the index, the second is the value (the component ID)\nval components = // YOUR CODE HERE\n\n// 2. Join the components with the indexedKeys DataFrame, so we get one original key (either session key or linking key)\n// 3. Keep only session keys (so we can put sessions together. Otherwise we could also put linking keys together)\n// 4. Extract session key and component id, forget other columns\nval sessionMapping = // YOUR CODE HERE","dateUpdated":"2018-07-04T17:13:19+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090182_-1702443713","id":"20160611-123902_2093568729","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27011"},{"text":"%md\n## 6. Check Results\nDo the results make sense? Let's have a look. We still have the original user names stored in our original sessions, let's join that data together with the sessionMapping. Let's see if all sessions belonging to a specific user do also have the same component ID.\n\n1. Create a key-value DataFrame (session, name) which maps a session to its user name. They DataFrame should only contain distinct values.\n2. Join the result to the key-value DataFrame\n3. Extract session, user name and user handle\n4. Sort result by user handle, fetch some entries => Do all entries of a user handle have the same user name?","dateUpdated":"2018-07-04T17:17:38+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>6. Check Results</h2>\n<p>Do the results make sense? Let&rsquo;s have a look. We still have the original user names stored in our original sessions, let&rsquo;s join that data together with the sessionMapping. Let&rsquo;s see if all sessions belonging to a specific user do also have the same component ID.</p>\n<ol>\n  <li>Create a key-value DataFrame (session, name) which maps a session to its user name. They DataFrame should only contain distinct values.</li>\n  <li>Join the result to the key-value DataFrame</li>\n  <li>Extract session, user name and user handle</li>\n  <li>Sort result by user handle, fetch some entries =&gt; Do all entries of a user handle have the same user name?</li>\n</ol>\n</div>"}]},"apps":[],"jobName":"paragraph_1530724090182_-1702443713","id":"20160611-124505_1367806648","dateCreated":"2018-07-04T17:08:10+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:27012","user":"anonymous","dateFinished":"2018-07-04T17:17:38+0000","dateStarted":"2018-07-04T17:17:38+0000"},{"text":"val sessionToUser = // YOUR CODE HERE\n\nval combinedUsers = // YOUR CODE HERE\n    \nz.show(combinedUsers.orderBy($\"user_handle\").limit(200))","dateUpdated":"2018-07-04T17:16:49+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[{"name":"session","index":0,"aggr":"sum"}],"values":[{"name":"user_handle","index":1,"aggr":"sum"}],"groups":[],"scatter":{"xAxis":{"name":"session","index":0,"aggr":"sum"}}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090183_-1702828462","id":"20160611-124521_33806293","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27013"},{"text":"%md\n## Find Connected Users with Multiple Names\nOnly sessions of a single user should be connected together, this means that a single user handle should map to a single name. Let's check this via some aggregation","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>Find Connected Users with Multiple Names</h2>\n<p>Only sessions of a single user should be connected together, this means that a single user handle should map to a single name. Let&rsquo;s check this via some aggregation</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1530724090183_-1702828462","id":"20180625-191356_56147580","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27014"},{"text":"val result = // YOUR CODE HERE\n\nz.show(result.limit(100))","dateUpdated":"2018-07-04T17:18:06+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090184_-1704752207","id":"20180624-175057_1873045425","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27015"},{"text":"%md\n## Find Names with disconnected Sessions\nIt can well happen that not all sessions of a single users are really connected together. Let's check that.","dateUpdated":"2018-07-04T17:08:10+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Find Names with disconnected Sessions</h2>\n<p>It can well happen that not all sessions of a single users are really connected together. Let's check that.</p>\n"}]},"apps":[],"jobName":"paragraph_1530724090184_-1704752207","id":"20180625-191547_734155092","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27016"},{"text":"val result = // YOUR CODE HERE\n\nz.show(result.limit(100))","dateUpdated":"2018-07-04T17:18:17+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090185_-1705136956","id":"20180624-175402_1192604169","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27017"},{"text":"result.count()","dateUpdated":"2018-07-04T17:08:10+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"res51: Long = 3415\n"}]},"apps":[],"jobName":"paragraph_1530724090185_-1705136956","id":"20180625-191638_1356484345","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27018"},{"text":"%md\n# Cleanup Memory","dateUpdated":"2018-07-04T17:08:10+0000","config":{"editorSetting":{},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Cleanup Memory</h1>\n"}]},"apps":[],"jobName":"paragraph_1530724090186_-1703982709","id":"20160611-101803_1360438852","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27019"},{"text":"sc.getPersistentRDDs.foreach { entry => entry._2.unpersist() }","dateUpdated":"2018-07-04T17:08:10+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1530724090186_-1703982709","id":"20160611-101823_1003062743","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27020"},{"dateUpdated":"2018-07-04T17:08:10+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1530724090187_-1704367458","id":"20160611-104058_1531646874","dateCreated":"2018-07-04T17:08:10+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27021"}],"name":"GraphX User Linking Skeleton","id":"2DHTPUACE","angularObjects":{"2D8DSN3N4:shared_process":[],"2D7W55G1J:shared_process":[],"2DA3X6UGN:shared_process":[],"2D9HTU14T:shared_process":[],"2DBA6X8JB:shared_process":[],"2DBSCZXK2:shared_process":[],"2D9M853BP:shared_process":[],"2DAXFQ4X2:shared_process":[],"2DB3TEGGU:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}