{"paragraphs":[{"text":"%md\n# Word Count Revisited\n\nNow we have a simple word counting algorithm, we want to extend it by two simple features:\n* We want to ignore some words, which are not interesting to use.\n* We want to have a counter showing how many words have been ignored.\n\nThese two features will be implemented using *broadcast variables* and *accumulators*.\n\nBut first let's have a look at the original word-count solution as a starting point.","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187742_-1269806998","id":"20170130-221734_229219199","result":{"code":"SUCCESS","type":"HTML","msg":"<h1>Word Count Revisited</h1>\n<p>Now we have a simple word counting algorithm, we want to extend it by two simple features:</p>\n<ul>\n<li>We want to ignore some words, which are not interesting to use.</li>\n<li>We want to have a counter showing how many words have been ignored.</li>\n</ul>\n<p>These two features will be implemented using <em>broadcast variables</em> and <em>accumulators</em>.</p>\n<p>But first let's have a look at the original word-count solution as a starting point.</p>\n"},"dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1419"},{"text":"// The original word count solution\nval text = sc.textFile(\"s3://dimajix-training/data/alice\")\nval words = text.flatMap(_.split(\" \"))\n    .filter(_ != \"\")\n    .map(x => (x,1))\n    .reduceByKey(_ + _)\n    .sortBy(_._2, ascending=false)\n    .map({ case (k,v) => k + '\\t' + v.toString() })\n    \nwords.take(10).foreach(println)","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170130-221747_308746184","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1420","focus":true},{"text":"%md\n# 1. Ignore Stop Words\n\nNow let's try to implement the first feature: We want to ignore words coming from a pre-defined set of uninteresting words. Specifically we want to ignore the following words:\n\n* the, a, an, and, of, I, she, it, to, in, was, *empty word* (\"\")\n \nFor implementing the stop word filter, we will perform the following steps.\n\n1. Create a Scala set of all stop words. We should make them also lowercase for simpler comparison\n2. Use SparkContext.broadcast to explicitly send this set to all worker nodes\n3. Create a simple function isStopWord that checks if a given word is part of the set.\n4. Modify original word count solution to use this new filter","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170218-122032_1842586031","result":{"code":"SUCCESS","type":"HTML","msg":"<h1>1. Ignore Stop Words</h1>\n<p>Now let's try to implement the first feature: We want to ignore words coming from a pre-defined set of uninteresting words. Specifically we want to ignore the following words:</p>\n<ul>\n<li>the, a, an, and, of, I, she, it, to, in, was, <em>empty word</em> (&ldquo;&ldquo;)</li>\n</ul>\n<p>For implementing the stop word filter, we will perform the following steps.</p>\n<ol>\n<li>Create a Scala set of all stop words. We should make them also lowercase for simpler comparison</li>\n<li>Use SparkContext.broadcast to explicitly send this set to all worker nodes</li>\n<li>Create a simple function isStopWord that checks if a given word is part of the set.</li>\n<li>Modify original word count solution to use this new filter</li>\n</ol>\n"},"dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1421"},{"text":"// 1. Create a Set of the mentioned stopWords, transform each word to lower case using the String method 'toLowerCase'\nval stopWords = ... // YOUR CODE HERE\n\n// 2. Create a broadcast variable from the set of stop words. This can be achieved by using the method SparkContext.broadcast\nval stopWordsBc = ... // YOUR CODE HERE\n\n// 3. Write a function 'isStopWord' which takes a single string as argument and returns true if the argument is in the list of stop words. \n//    Inside the function (which will be executed in a distributed manner on all nodes), we need to access the broadcast variable. You can\n//    retrieve the original Scala set of words by using stopWordsBc.value. Do not forget to transform the incoming word to lower case!\ndef isStopWord(word:String) = ... // YOUR CODE HERE","dateUpdated":"2017-02-18T12:52:17+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170218-122155_1057252807","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1422","focus":true},{"text":"%md\nNow that we have everything in place, we only need to modify the previous solution by replacing the filter operation","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170218-122902_455043473","result":{"code":"SUCCESS","type":"HTML","msg":"<p>Now that we have everything in place, we only need to modify the previous solution by replacing the filter operation</p>\n"},"dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1423"},{"text":"// 4. Modify the original program to use the new filter\nval text = sc.textFile(\"s3://dimajix-training/data/alice\")\nval words = ... // YOUR CODE HERE\n\nwords.take(10).foreach(println)","dateUpdated":"2017-02-18T12:52:45+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":false,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170218-122522_1465615836","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1424","focus":true},{"text":"%md\n# 2. Count invocations of isStopWord inclusing results\nNow that we have a nice and efficient solution in place, we also might want to count how often a word was rejected or accepted, i.e. how often isStopWord returns true or false. Of course we could simply perform a `count` after the filter, but this might not work in more complex scenarios, or this might be very expensive. \n\nWhat we really want is two simple counters that are increased whenever a word is filtered or accepted. Unfortunately this is not trivial in a distributed environment, so we cannot use a simple Scala variable. But again, Spark comes to the resuce and offers us *Accumulators*, which are distributed counters.\n\n1. Create two Accumulators using SparkContext.longAccumulator(name)\n2. Create a new filter function `isStopWord` which also increments the appropriate accumulator\n3. Rerun word count with new isStopWord function\n4. Inspect the value of both accumulators\n","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170130-221810_265200548","result":{"code":"SUCCESS","type":"HTML","msg":"<h1>2. Count invocations of isStopWord inclusing results</h1>\n<p>Now that we have a nice and efficient solution in place, we also might want to count how often a word was rejected or accepted, i.e. how often isStopWord returns true or false. Of course we could simply perform a <code>count</code> after the filter, but this might not work in more complex scenarios, or this might be very expensive.</p>\n<p>What we really want is two simple counters that are increased whenever a word is filtered or accepted. Unfortunately this is not trivial in a distributed environment, so we cannot use a simple Scala variable. But again, Spark comes to the resuce and offers us <em>Accumulators</em>, which are distributed counters.</p>\n<ol>\n<li>Create two Accumulators using SparkContext.longAccumulator(name)</li>\n<li>Create a new filter function <code>isStopWord</code> which also increments the appropriate accumulator</li>\n<li>Rerun word count with new isStopWord function</li>\n<li>Inspect the value of both accumulators</li>\n</ol>\n"},"dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1425"},{"text":"// 1. Create two accumulators, one for the number of stop words, and another one for the number of all other words.\nval stopWordCounter = sc.longAccumulator(\"stop_words\")\nval otherWordCounter = ... // YOUR CODE HERE\n\n// 2. ReWrite a function 'isStopWord' to increment the appropriate accumulator using the method 'add' of each accumulator\ndef isStopWord(word:String) = {\n    val result = stopWordsBc.value.contains(word.toLowerCase)\n    // Now increase either stopWordCounter or otherWordCounter\n    // YOUR CODE HERE\n    \n    // Do not forget to return original result\n    // YOUR CODE HERE\n}","dateUpdated":"2017-02-18T12:53:57+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170130-221759_788343263","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1426","focus":true},{"text":"// 3. Rerun word count\nval text = sc.textFile(\"s3://dimajix-training/data/alice\")\nval words = text.flatMap(_.split(\" \"))\n    .filter(!isStopWord(_))\n    .map(x => (x,1))\n    .reduceByKey(_ + _)\n    .sortBy(_._2, ascending=false)\n    .map({ case (k,v) => k + '\\t' + v.toString() })\n\nwords.take(10).foreach(println)","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170218-121456_1172349725","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1427","focus":true},{"text":"// 4. Print accumulators. You can access the actual value with the 'value' member of each accumulator\nprintln(s\"Stop words: ${stopWordCounter.value}\")\nprintln(...) // YOUR CODE HERE","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187743_-1270191747","id":"20170218-124408_2146008077","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1428","focus":true},{"text":"","dateUpdated":"2017-02-18T12:49:47+0000","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487422187744_-1284427456","id":"20170218-124622_2016533883","dateCreated":"2017-02-18T12:49:47+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1429"}],"name":"WordCount with StopWords - Exercise","id":"2C8NE7R8R","angularObjects":{"2BRWU4WXC:shared_process":[],"2AM1YV5CU:shared_process":[],"2AJXGMUUJ:shared_process":[],"2ANGGHHMQ:shared_process":[],"2AKK3QQXU:shared_process":[]},"config":{"looknfeel":"default"},"info":{}}